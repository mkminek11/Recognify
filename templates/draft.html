
{#
Args:
  - draft: Draft - The draft object being edited.
#}

{% extends "base.html" %}
{% from 'components/input.html' import input %}
{% from 'components/collapse.html' import collapse %}
{% from 'components/popup_message.html' import message_list %}

{% block content %}
    <div x-data="formHandler" class="container">
        <dialog x-ref="inaturalistDialog">
            <button @click="$refs.inaturalistDialog.close()">Close</button>
            <h2>Import from iNaturalist</h2>
            <p>Write species names here, each on a new line.</p>
            <textarea x-ref="inaturalistTextarea"></textarea>
            <button @click="importFromInaturalist()">Import</button>
        </dialog>

        <dialog x-ref="importedImagesDialog">
            <button @click="$refs.inaturalistDialog.close()">Close</button>
            <h2>Imported Images</h2>

            <div>
                <template x-for="([species, images], spIndex) in Object.entries(importedImageLinks)" :key="spIndex">
                    <div>
                        <p x-text="species"></p>
                        <template x-for="(image, index) in images" :key="index">
                            <div>
                                <input type="checkbox" :id="`imported_${spIndex}_${image.id}`" x-model="image.selected" />
                                <label x-bind:for="`imported_${spIndex}_${image.id}`">
                                    <img :src="image.imageLink" width="100"
                                        :class="{ 'checked': image.selected }" />
                                </label>
                            </div>
                        </template>
                        <hr>
                    </div>
                </template>
            </div>

            <button :disabled="!anyImageSelected()" @click="insertImportedImages()">Insert</button>
        </dialog>

        <dialog x-ref="accessDialog">
            <button @click="$refs.accessDialog.close()">Close</button>
            <h2>Set Access</h2>
            <p>Who can access this set?</p>
            <input x-ref="accessAddInput" type="text" placeholder="Add user by email or name" />
            <button @click="addUserAccess()">Add</button>
            <div>
                <template x-for="(user, index) in accessUsers" :key="index">
                    <div>
                        <span x-text="user.username"></span>
                        <button @click="removeUserAccess(index)">Remove</button>
                    </div>
                </template>
            </div>
        </dialog>

        {% include 'components/navigation.html' %}

        <h2 class="draft-title">Editing draft "<span x-text="title"></span>"</h2>

        {{ message_list(ref="popupMessages") }}

        <main class="draft-body">
            <section class="sidebar sidebar-left">
                <div class="sidebar-header">
                    <h3>Images</h3>

                    <input type="file" id="images" class="hidden" x-ref="imageInput" multiple @change="addImages($event)" />
                    <input type="file" id="pres" class="hidden" x-ref="presInput" @change="preparePres($event)" />

                    {% call collapse() %}
                        <label for="images" class="collapse-item" title="Add image from file"><i class="icon fas fa-file-arrow-up"></i></label>
                        <div class="collapse-item" title="Add from URL" @click="addURL()"><i class="icon fas fa-cloud-arrow-up"></i></div>
                        <div class="collapse-item" title="Import from iNaturalist" @click="$refs.inaturalistDialog.showModal()"><i class="icon fas fa-dove"></i></div>
                        <label for="pres" class="collapse-item" title="Extract from a presentation"><i class="icon fas fa-person-chalkboard"></i></label>
                    {% endcall %}
                </div>

                <div class="image-gallery">
                    <template x-for="(imageWrapper, index) in images" :key="index">
                        <div class="gallery-item" :class="{ 'active': index === currentIndex }" @click="currentIndex = index">
                            <img :src="imageWrapper.image.data" />
                            <p x-text="imageLabels[imageWrapper.image.hash] || '-'"></p>
                            <i class="icon fas fa-trash-can" @click.stop="removeImage(index)"></i>
                        </div>
                    </template>
                </div>
            </section>

            <section class="main">
                <div class="image-main">
                    <img class="main-image" height="" :src="images[currentIndex]?.image.data" />

                    <div class="image-icons">
                        <!-- <i class="icon fas fa-pen" title="Replace image"></i> -->
                        <i class="icon fas fa-trash-can" title="Delete image" @click="removeImage(currentIndex)"></i>
                    </div>

                    <input type="file"
                        id="replace_from_file"
                        class="hidden"
                        x-ref="replaceFromFileInput"
                        @change="replaceFromFileEvent($event)"
                        accept="image/*" />
                </div>

                <div class="image-label">
                    <h3>Image label</h3>
                    {% call input(placeholder="Enter image label...", kw={
                        "x-model": "imageLabels[images[currentIndex]?.image.hash]",
                        "x-ref": "imageLabelInput",
                        "@blur": "saveImageLabel(currentIndex)",
                        "@keydown.enter": "saveAndNext()",
                        "@input": "imageInput()"}) %}

                        <i class="icon fas fa-check"></i>
                    {% endcall %}
                </div>

                <div class="suggestions" x-show="labels.filter(l => l.slide === images[currentIndex]?.slide).length > 0">
                    <template x-for="(label, index) in labels.filter(l => l.slide === images[currentIndex]?.slide)" :key="index">
                        <div class="suggestion-item">
                            <span class="suggestion-index" x-text="index + 1"></span>
                            <span class="suggestion-label" x-text="label.label"></span>
                        </div>
                    </template>
                </div>
            </section>

            <section class="sidebar sidebar-right">
                <div class="sidebar-header">
                    <h3>Settings</h3>
                </div>

                <dl>
                    <dt>
                        <span>Title</span>
                        <i class="icon fas" :class="{'fa-pen': !titleEditMode, 'fa-check': titleEditMode}"
                                @click="titleEditMode = !titleEditMode"></i>
                    </dt>
                    <dd>
                        <span x-text="title" x-show="!titleEditMode"></span>
                        <input type="text" x-ref="titleInput" x-model="title" x-show="titleEditMode" @blur="saveTitle();" />
                    </dd>

                    <dt>
                        <span>Description</span>
                        <i class="icon fas" :class="{'fa-pen': !descriptionEditMode, 'fa-check': descriptionEditMode}"
                                @click="descriptionEditMode = !descriptionEditMode"></i>
                    </dt>
                    <dd>
                        <span x-text="setDescription" x-show="!descriptionEditMode"></span>
                        <textarea x-ref="descriptionInput" x-model="setDescription"
                                x-show="descriptionEditMode" @blur="saveDescription();"></textarea>
                    </dd>

                    <dt>
                        <span><label for="setVisibility">Visibility</label></span>
                    </dt>
                    <dd>
                        <select id="setVisibility" x-model="visibility" @change="changeVisibility()">
                            <option value="private">Private</option>
                            <option value="public">Public</option>
                        </select>
                </dl>

                <p class="link danger" @click="deleteSet()">Delete draft</p>

                <button class="btn-primary" @click="publishDraft()">Publish</button>
            </section>
        </main>
    </div>
{% endblock %}

{% block scripts %}
    <script type="module">
        import { CustomImage } from '/static/js/CustomImage.js';
        window.CustomImage = CustomImage;
    </script>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('formHandler', () => ({
                title: '{{ draft.name or "Untitled Set" }}',
                setDescription: '{{ draft.description or "" }}',
                visibility: '{{ "public" if draft.is_public else "private" }}',
                titleEditMode: false,
                descriptionEditMode: false,
                images: [], // [ { image: CustomImage, slide: string } ]
                imageLabels: {}, // { imageHash: string -> label: string }
                labels: [], // list of { label: string, slide: string }
                importedImageLinks: {}, // { species: string -> [
                                        //     { imageLink: string, label: string, id: int, selected: boolean }
                                        // ] }
                accessUsers: JSON.parse('{{ get_data(draft.get_access_users()) }}'), // list of { id: str, name: string, email: string }
                currentIndex: 0,
                loadingImages: new Set(), // Track which image indices are currently being loaded


                init() {
                    if (this.title === 'Untitled Set' || !this.title.trim()) {
                        this.titleEditMode = true;
                        this.$refs.titleInput.focus();
                    }
                    this.$refs.imageInput.value = '';
                    this.$refs.presInput.value = '';
                    this.fetchGallery();
                    
                    // Watch for currentIndex changes to load focused image immediately
                    this.$watch('currentIndex', (newIndex) => {
                        this.loadImageAtIndex(newIndex);
                        
                        // Scroll the selected gallery item into view if it's not visible
                        this.$nextTick(() => {
                            const galleryRect = document.querySelector('.image-gallery')?.getBoundingClientRect();
                            const itemRect = gallery?.querySelector('.gallery-item.active').getBoundingClientRect();
                            if (!itemRect || !galleryRect) {return;}

                            // Check if item is outside visible area
                            if (itemRect.top < galleryRect.top || itemRect.bottom > galleryRect.bottom) {
                                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        });
                    });
                },

                async saveTitle() {
                    this.titleEditMode = false;
                    if (!this.title.trim()) {this.title = 'Untitled Set';}

                    this.title = this.title.trim();
                    const result = await axios.post('/api/draft/{{ draft.hid() }}/rename', { title: this.title });
                },

                saveDescription() {
                    axios.post('/api/draft/{{ draft.hid() }}/description', { description: this.setDescription });
                },

                saveImageLabel(index) {
                    console.log("Blur");
                    const image = this.images[index].image;
                    const label = this.imageLabels[image.hash] || '';
                    axios.post('/api/draft/{{ draft.hid() }}/image/' + image.dbid, { label });
                },

                async saveAndNext() {
                    this.saveImageLabel(this.currentIndex);
                    
                    if (this.currentIndex < this.images.length - 1) {
                        this.currentIndex++;
                        this.$nextTick(() => {
                            this.$refs.imageLabelInput.focus();
                            this.$refs.imageLabelInput.select();
                        });
                    }
                },

                async replacePlaceholderWithImage(index, imageData) {
                    const cimg = await window.CustomImage.fromUrl('/api/draft/{{ draft.hid() }}/image/' + imageData.id, imageData.id);
                    await cimg.ready;
                    cimg.dbid = imageData.id;
                    
                    const placeholderKey = 'placeholder_' + index;
                    const existingLabel = this.imageLabels[placeholderKey];
                    const labelToSet = existingLabel || imageData.label || '';
                    
                    // Update the image object
                    this.images[index] = { image: cimg, slide: imageData.slide };
                    
                    // Update labels - delete old key first, then add new
                    delete this.imageLabels[placeholderKey];
                    this.imageLabels[cimg.hash] = labelToSet;
                    
                    // Force a minimal re-render by touching the images array
                    this.images = [...this.images];
                },

                async loadImageAtIndex(index) {
                    if (index < 0 || index >= this.images.length) return;
                    const imageWrapper = this.images[index];
                    
                    // Skip if already loaded or currently loading
                    if (!imageWrapper || !imageWrapper.isPlaceholder || this.loadingImages.has(index)) {
                        return;
                    }
                    
                    // Mark as loading
                    this.loadingImages.add(index);
                    
                    try {
                        await this.replacePlaceholderWithImage(index, imageWrapper.originalData);
                    } catch (error) {
                        console.error('Failed to load image at index', index, error);
                    } finally {
                        // Remove from loading set when done (success or failure)
                        this.loadingImages.delete(index);
                    }
                },

                removeImage(index) {
                    const image = this.images[index].image;
                    
                    // Remove the image from the array first
                    this.images.splice(index, 1);

                    // Then delete its label (after splice to ensure reactivity works correctly)
                    if (image && image.hash) {
                        delete this.imageLabels[image.hash];
                    }

                    if (this.currentIndex >= this.images.length) {
                        this.currentIndex = this.images.length - 1;
                    }

                    axios.delete('/api/draft/{{ draft.hid() }}/image/' + image.dbid);
                },

                async addImages(event) {
                    const fd = new FormData();
                    const files = event.target.files;
                    let added = 0;

                    for (const file of files) {
                        // if (file.size > 10 * 1024 * 1024) {continue;} // 10MB limit
                        fd.append('images', file);

                        const cimg = window.CustomImage.fromFile(file);
                        await cimg.ready;

                        if (!this.images.some(existing => existing.image.hash === cimg.hash)) {
                            this.images.push({ image: cimg, slide: "" });
                            this.imageLabels[cimg.hash] = '';
                            added++;
                        }
                    }

                    let ids = await axios.post('/api/draft/{{ draft.hid() }}/gallery', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    for (let i = 0; i < added; i++) {
                        this.images[this.images.length - added + i].image.dbid = ids.data.images[i].id;
                        this.images[this.images.length - added + i].slide = ids.data.images[i].slide;
                    }
                },

                async addURL() {
                    const url = prompt("Insert image URL:");
                    if (!url) return;

                    try {
                        const cimg = await window.CustomImage.fromUrl(url);
                        await cimg.ready;

                        if (this.images.some(existing => existing.image.hash === cimg.hash)) {
                            alert("This image is already added.");
                            return;
                        }

                        const result = await axios.post('/api/draft/{{ draft.hid() }}/gallery/url', { url });
                        cimg.dbid = result.data.id;

                        this.images.push({ image: cimg, slide: "" });
                        this.imageLabels[cimg.hash] = '';

                        // this.$refs.imgURL.value = '';
                    } catch (error) {
                        alert("Failed to add image from URL.");
                        console.error(error);
                    }
                },

                replaceFromFile(index) {
                    this.$refs.replaceFromFileInput.dataset.index = index;
                },

                async replaceFromFileEvent(event) {
                    const index = this.$refs.replaceFromFileInput.dataset.index;
                    const file = event.target.files[0];
                    if (!file) return;

                    const fd = new FormData();
                    fd.append('image', file);
                    fd.append('replace_id', this.images[index].image.dbid);
                    const cimg = window.CustomImage.fromFile(file, this.images[index].image.dbid);
                    await cimg.ready;

                    await axios.put('/api/draft/{{ draft.hid() }}/image/' + this.images[index].image.dbid + '/file', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    this.images[index].image = cimg;
                    this.$refs.replaceFromFileInput.value = '';
                },

                async replaceFromURL(index) {
                    url = prompt("Insert image URL:");
                    if (!url) {return;}
                    const cimg = await window.CustomImage.fromUrl(url, this.images[index].image.dbid);
                    await cimg.ready;
                    
                    const fd = new FormData();
                    fd.append('url', url);
                    fd.append('replace_id', cimg.dbid);
                    await axios.put('/api/draft/{{ draft.hid() }}/image/' + this.images[index].image.dbid + '/url', fd);

                    this.images[index].image = cimg;
                },

                async preparePres(event) {
                    let messageId = this.addMessage('loading', 'Extracting images from presentation. This may take a while...', -1);

                    const file = event.target.files[0];
                    if (!file) return;

                    const formData = new FormData();
                    formData.append('presentation', file);
                    formData.append('draft', '{{ draft.hid() }}');

                    const results = await axios.post('/api/draft/{{ draft.hid() }}/presentation', formData, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    const images = results.data.images || [];
                    const labels = results.data.labels || [];
                    console.log("Presentation images:", images);

                    this.removeMessage(messageId);
                    await this.addToGallery(images, labels);
                },

                async fetchGallery() {
                    const result = await axios.get('/api/draft/{{ draft.hid() }}/gallery');
                    const images = result.data.images || [];
                    const labels = result.data.labels || [];
                    await this.addToGallery(images, labels);
                    console.log("Fetched gallery images:", images);
                },

                async addToGallery(images, labels = []) {
                    // Add labels first (lightweight)
                    for (const labelData of labels) {
                        if (!this.labels.some(existing => existing.label === labelData.text && existing.slide === labelData.slide)) {
                            this.labels.push({ label: labelData.label, slide: labelData.slide });
                        }
                    }

                    if (images.length == 0) {return;}
                    
                    // Filter out images that are already loaded (by dbid)
                    const existing = new Set(this.images.map(img => img.image.dbid).filter(id => id));
                    const newImages = images.filter(imageData => !existing.has(imageData.id));
                    
                    if (newImages.length == 0) {return;}
                    
                    // Track the starting position in the images array
                    const startIndex = this.images.length;
                    
                    // Create placeholder objects for all new images immediately
                    const placeholders = newImages.map((imageData, index) => ({
                        image: {
                            data: 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-family=%22sans-serif%22 font-size=%2214%22%3ELoading %23' + (index + 1) + '%3C/text%3E%3C/svg%3E',
                            hash: 'placeholder_' + (startIndex + index),
                            dbid: imageData.id,
                        },
                        slide: imageData.slide,
                        isPlaceholder: true,
                        imageDataId: imageData.id,
                        originalData: imageData,
                    }));
                    
                    // Add all placeholders to show what's coming
                    this.images.push(...placeholders);
                    
                    // Initialize labels for placeholders
                    for (let i = 0; i < placeholders.length; i++) {
                        const imageData = newImages[i];
                        this.imageLabels['placeholder_' + (startIndex + i)] = imageData.label || '';
                    }
                    
                    // Load actual images one by one in the background, replacing placeholders
                    (async () => {
                        for (let i = 0; i < newImages.length; i++) {
                            const imageData = newImages[i];
                            const arrayIndex = startIndex + i;
                            
                            // Skip if already loaded or currently being loaded
                            if (!this.images[arrayIndex] || !this.images[arrayIndex].isPlaceholder || this.loadingImages.has(arrayIndex)) {
                                continue;
                            }
                            
                            // Mark as loading
                            this.loadingImages.add(arrayIndex);
                            
                            try {
                                await this.replacePlaceholderWithImage(arrayIndex, imageData);
                            } catch (error) {
                                console.error('Failed to load image:', imageData.id, error);
                            } finally {
                                // Remove from loading set
                                this.loadingImages.delete(arrayIndex);
                            }
                        }
                    })();
                },

                imageInput() {
                    const image = this.images[this.currentIndex].image;
                    const imageWrapper = this.images[this.currentIndex];
                    const input = this.$refs.imageLabelInput;
                    const value = input.value;

                    console.log("Input ", input, " changed for image", image.hash, "to", value);

                    if (!/^[1-9]$/.test(value)) {return;}

                    console.log("Valid number input:", value);

                    const nextIndex = this.currentIndex + 1;
                    this.$nextTick(() => {
                        const number = parseInt(value, 10);
                        console.log("Parsed number:", number);

                        // Filter labels by the EXACT slide identifier (which is unique per presentation)
                        const filtered = this.labels.filter(l => l.slide === imageWrapper.slide);
                        console.log("Filtered labels for slide", imageWrapper.slide, ":", filtered);
                        if (filtered.length < number) {return;}
                        const label = filtered[number - 1].label;
                        console.log("Mapped number", number, "to label", label);

                        // Set the value and focus next input
                        this.imageLabels[image.hash] = label;
                        input.value = label;
                        this.saveImageLabel(this.currentIndex);
                        
                        if (nextIndex < this.images.length) {
                            this.currentIndex = nextIndex;
                            this.$nextTick(() => {
                                input.focus();
                                input.select();
                            });
                        }
                    });
                },

                async publishDraft(event) {
                    this.saveTitle();
                    this.saveDescription();
                    if (this.images.length > 0 && this.currentIndex >= 0) {
                        this.saveImageLabel(this.currentIndex);
                    }

                    if (event) {event.preventDefault();}
                    if (!confirm("Are you sure you want to publish this set? You will be able to edit it later.")) {return;}

                    let result = await axios.post('/api/draft/{{ draft.hid() }}/submit');
                    if (result.status === 200) {
                        alert("Set published successfully!");
                    }
                },

                async deleteSet() {
                    if (!confirm("Are you sure you want to delete this set? This action cannot be undone.")) {
                        return;
                    }

                    await axios.delete('/api/draft/{{ draft.hid() }}');
                    window.location.href = '/';
                },

                async importFromInaturalist() {
                    let messageId = this.addMessage('loading', 'Importing images from iNaturalist. This may take a while...', 1000);

                    const textarea = this.$refs.inaturalistTextarea;
                    const speciesNames = textarea.value.split('\n').map(name => name.trim()).filter(name => name);
                    this.$refs.inaturalistDialog.close();

                    await axios.get('/api/inaturalist/links', {
                        params: { species: speciesNames.join(',') },
                        timeout: 12000
                    }).then(async (response) => {
                        const imageSets = response.data.links || {};
                        this.importedImageLinks = {};
                        this.$refs.importedImagesDialog.showModal();

                        console.log("Received image sets:", imageSets);
                        
                        for (const [species, urls] of Object.entries(imageSets)) {
                            for (let i = 0; i < urls.length; i++) {
                                const url = urls[i];
                                console.log("Processing URL:", url);
                                let id = i;
                                this.importedImageLinks[species] = this.importedImageLinks[species] || [];
                                this.importedImageLinks[species].push({ imageLink: url, label: species, id: id, selected: false });
                            }
                        }

                        console.log("Imported image links:", this.importedImageLinks);
                        this.removeMessage(messageId);
                    }).catch((error) => {
                        this.removeMessage(messageId);
                        const errorMsg = error.response?.data?.error || error.message || 'Unknown error occurred';
                        this.addMessage('error', `Failed to import from iNaturalist: ${errorMsg}`, 5000);
                        console.error('iNaturalist import error:', error);
                    });
                },
            
                async insertImportedImages() {
                    this.addMessage('loading', 'Inserting selected images...', 1000);

                    this.$refs.importedImagesDialog.close();

                    // Collect all selected images first
                    const selectedImages = [];
                    for (const species in this.importedImageLinks) {
                        for (const imageData of this.importedImageLinks[species]) {
                            if (imageData.selected) {
                                selectedImages.push(imageData);
                            }
                        }
                    }

                    // Process all selected images in parallel
                    const imagePromises = selectedImages.map(async ({ imageLink: url, label, id }) => {
                        const cimg = await window.CustomImage.fromUrl(url);
                        await cimg.ready;
                        return { cimg, label, url };
                    });
                    
                    const imageResults = await Promise.all(imagePromises);
                    
                    // Add images to gallery sequentially to maintain order
                    for (const { cimg, label, url } of imageResults) {
                        if (this.images.some(existing => existing.image.hash === cimg.hash)) {
                            console.log("This image is already added.");
                            continue;
                        }

                        const result = await axios.post('/api/draft/{{ draft.hid() }}/gallery/url', { url });
                        cimg.dbid = result.data.id;

                        this.images.push({ image: cimg, slide: "" });
                        this.imageLabels[cimg.hash] = label;

                        axios.post('/api/draft/{{ draft.hid() }}/image/' + cimg.dbid, { label });
                    }

                    this.removeMessage('loading');
                },

                changeVisibility() {
                    const isPublic = this.visibility === 'public';
                    axios.post('/api/draft/{{ draft.hid() }}/visibility', { is_public: isPublic });
                },

                anyImageSelected() {
                    return Object.values(this.importedImageLinks).some(images => images.some(image => image.selected));
                },
            
                async addUserAccess() {
                    const nameOrEmail = this.$refs.accessAddInput.value.trim();
                    if (!nameOrEmail) return;

                    await axios.post('/api/draft/{{ draft.hid() }}/access', { user: nameOrEmail }).then((response) => {
                        const user = response.data.user;
                        if (!user) {alert("User not found."); return;}
                        this.accessUsers.push(user);
                        this.$refs.accessAddInput.value = '';
                    }).catch((error) => {
                        alert("Failed to add user access: " + error.response.data.error);
                    });
                },

                async removeUserAccess(index) {
                    const user = this.accessUsers[index];
                    await axios.delete('/api/draft/{{ draft.hid() }}/access', { user: user.id }).then((response) => {
                        if (response.status === 200) {this.accessUsers.splice(index, 1);}
                    }).catch((error) => {
                        alert("Failed to remove user access: " + error.response.data.error);
                    });
                },
            
                addMessage(type, text, duration = 10) {
                    let id = crypto.randomUUID();
                    this.$dispatch('add-message', { id, type, text, duration: duration * 1000 });
                    return id;
                },

                removeMessage(id) {
                    this.$dispatch('remove-message', { id });
                },
            }));
        });
    </script>
{% endblock %}

{% block styles %}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/draft.css') }}">
{% endblock %}
