{% extends "base.html" %}

{% block content %}
    <h1>Create a New Set</h1>
    <div x-data="formHandler" x-init="init()">
        <div>
            <label for="name">Set title:</label>
            <input type="text" id="name" x-ref="titleInput" x-model="title" x-show="titleEditMode" @blur="saveTitle();" />
            <span x-text="title" x-show="!titleEditMode" @click="titleEditMode = true; $nextTick(() => $refs.titleInput.focus())"></span>
        </div>
    
        <label for="description">Description:</label>
        <textarea id="description" x-model="setDescription" @blur="saveDescription()"></textarea>

        <button @click="deleteSet">Delete Set</button>
    
        <div>
            <p>Add images:</p>
            <label for="images" class="btn">Upload</label>
            <input type="file" id="images" class="hidden" x-ref="imageInput" multiple @change="addImages($event)" />

            <!-- <label for="img_online">Add online:</label> -->
            <input type="url" id="img_url" x-ref="imgURL" placeholder="Image URL" />
            <button @click="addURL">Add URL</button>

            <label for="pres" class="btn">Extract from a presentation</label>
            <input type="file" id="pres" class="hidden" x-ref="presInput" @change="preparePres($event)" />

            <div x-ref="imageList">
                <template x-for="(image, index) in images" :key="index">
                    <div>
                        <img :src="image.image.src" width="100" />
                        <input type="text" 
                               :id="`input_${index}`"
                               x-model="imageLabels[image.image.hash]" 
                               placeholder="Enter image caption" 
                               @blur="saveImageLabel(index)" 
                               @input="imageInput($event, index)" />
                        <button @click="removeImage(index)" tabindex="-1">Remove</button>
                        <label for="change_from_file" @click="changeFromFile(index)" tabindex="-1">Change from file</label>
                        <button @click="changeFromURL(index)" tabindex="-1">Change from URL</button>
                        <ul>
                            <template x-for="(label, labelIndex) in labels.filter(l => l.slide === image.slide)" :key="labelIndex">
                                <li x-text="`${labelIndex + 1}. ${label.label}`"></li>
                            </template>
                        </ul>
                    </div>
                </template>
            </div>
        </div>
    
        <button @click="submitForm">Create Set</button>
        <input type="file"
               id="change_from_file"
               class="hidden-fixed"
               x-ref="changeFromFileInput"
               @change="changeFromFileEvent($event)"
               accept="image/*" />
    </div>
{% endblock %}

{% block scripts %}
    <script type="module">
        import { CustomImage } from '/static/js/CustomImage.js';
        window.CustomImage = CustomImage;
    </script>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('formHandler', () => ({
                title: '{{ draft.name or "Untitled Set" }}',
                setDescription: '{{ draft.description or "" }}',
                titleEditMode: true,
                images: [], // list of { image: CustomImage, slide: string }
                imageLabels: {}, // map of imageHash: string -> label: string
                labels: [], // list of { label: string, slide: string }

                init() {
                    this.$refs.titleInput.focus();
                    this.$refs.imageInput.value = '';
                    this.$refs.presInput.value = '';
                    this.fetchGallery();
                },

                async saveTitle() {
                    this.titleEditMode = false;
                    if (!this.title.trim()) {this.title = 'Untitled Set';}

                    this.title = this.title.trim();
                    const result = await axios.post('/api/draft/{{ draft.hash() }}/rename', { title: this.title });
                },

                async saveDescription() {
                    const result = await axios.post('/api/draft/{{ draft.hash() }}/description', { description: this.setDescription });
                },

                async saveImageLabel(index) {
                    console.log("Blur");
                    const image = this.images[index].image;
                    const label = this.imageLabels[image.hash] || '';
                    await axios.post('/api/draft/{{ draft.hash() }}/image/' + image.id, { label });
                },

                removeImage(index) {
                    const image = this.images[index].image;
                    if (image && image.hash) {
                        delete this.imageLabels[image.hash];
                    }
                    this.images.splice(index, 1);

                    axios.delete('/api/draft/{{ draft.hash() }}/image/' + image.id);
                },

                async addImages(event) {
                    const fd = new FormData();
                    const files = event.target.files;
                    let added = 0;

                    for (const file of files) {
                        // if (file.size > 10 * 1024 * 1024) {continue;} // 10MB limit
                        fd.append('images', file);

                        const cimg = new window.CustomImage(file);
                        await cimg.ready;

                        if (!this.images.some(existing => existing.image.hash === cimg.hash)) {
                            this.images.push({ image: cimg, slide: "" });
                            this.imageLabels[cimg.hash] = '';
                            added++;
                        }
                    }

                    let ids = await axios.post('/api/draft/{{ draft.hash() }}/gallery', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    for (let i = 0; i < added; i++) {
                        this.images[this.images.length - added + i - 1].image.id = ids.data.images[i].id;
                    }
                },

                async addURL() {
                    const url = this.$refs.imgURL.value.trim();
                    if (!url) return;

                    try {
                        const cimg = new window.CustomImage(url);
                        await cimg.ready;

                        if (this.images.some(existing => existing.image.hash === cimg.hash)) {
                            alert("This image is already added.");
                            return;
                        }

                        const result = await axios.post('/api/draft/{{ draft.hash() }}/gallery/url', { url });
                        cimg.id = result.data.id;

                        this.images.push({ image: cimg, slide: "" });
                        this.imageLabels[cimg.hash] = '';

                        this.$refs.imgURL.value = '';
                    } catch (error) {
                        alert("Failed to add image from URL.");
                        console.error(error);
                    }
                },

                changeFromFile(index) {
                    this.$refs.changeFromFileInput.dataset.index = index;
                },

                async changeFromFileEvent(event) {
                    const index = this.$refs.changeFromFileInput.dataset.index;
                    const file = event.target.files[0];
                    if (!file) return;

                    console.log(`Image src: ${this.images[index].image.src}`);

                    const fd = new FormData();
                    fd.append('image', file);
                    fd.append('change_id', this.images[index].image.id);
                    const cimg = new window.CustomImage(file);
                    cimg.id = this.images[index].image.id;
                    await cimg.ready;

                    await axios.post('/api/draft/{{ draft.hash() }}/change/image', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });
                    console.log(`New Image src: ${cimg.src}`);

                    this.images[index].image = cimg;
                    this.$refs.changeFromFileInput.value = '';
                },

                async preparePres(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    // if (file.size > 50 * 1024 * 1024) {return;} // 50MB limit
                    // Musel jsem to zakomentovat kvuli prezentaci na rostliny, ktera mela pres pul giga xd

                    const formData = new FormData();
                    formData.append('presentation', file);
                    formData.append('draft', '{{ draft.hash() }}');

                    const results = await axios.post('/api/presentation', formData, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    const images = results.data.images || [];
                    const labels = results.data.labels || [];
                    console.log("Presentation images:", images);
                    await this.addToGallery(images, labels);
                },

                async fetchGallery() {
                    const result = await axios.get('/api/draft/{{ draft.hash() }}/gallery');
                    const images = result.data.images || [];
                    const labels = result.data.labels || [];
                    await this.addToGallery(images, labels);
                },

                async addToGallery(images, labels = []) {
                    // Process all images in parallel instead of sequentially
                    const imagePromises = images.map(async (imageData) => {
                        const cimg = new window.CustomImage('/api/draft/{{ draft.hash() }}/image/' + imageData.id, null, imageData);
                        await cimg.ready;
                        return { cimg, imageData };
                    });
                    
                    const imageResults = await Promise.all(imagePromises);
                    
                    for (const { cimg, imageData } of imageResults) {
                        if (!this.images.some(existing => existing.image.hash === cimg.hash)) {
                            this.images.push({ image: cimg, slide: imageData.slide });
                            this.imageLabels[cimg.hash] = imageData.label || '';
                        }
                    }

                    for (const labelData of labels) {
                        if (!this.labels.some(existing => existing.label === labelData.text && existing.slide === labelData.slide)) {
                            this.labels.push({ label: labelData.text, slide: labelData.slide });
                        }
                    }
                },

                async imageInput(event, index) {
                    const image = this.images[index].image;
                    const input = event.target;
                    const value = input.value;

                    console.log("Input ", input, " changed for image", image.hash, "to", value);

                    if (!/^[1-9]$/.test(value)) {return;}

                    const nextIndex = index + 1;
                    this.$nextTick(() => {
                        const number = parseInt(value, 10);
                        const label = this.labels.filter(l => l.slide === image.slide)[number - 1].label;
                        console.log("Mapped number", number, "to label", label);

                        // Set the value and focus next input
                        this.imageLabels[image.hash] = label;
                        
                        // Focus the next input using getElementById
                        if (nextIndex >= this.images.length) {return;}
                        this.$nextTick(() => {
                            this.saveImageLabel(index);
                            
                            const nextInput = document.getElementById(`input_${nextIndex}`);
                            console.log("Next input:", nextInput, "index:", nextIndex);
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select(); // Select text for better UX
                            } else {
                                console.log("Input not found for id:", `input_${nextIndex}`);
                            }
                        });
                    });
                },

                async submitForm(event) {
                    if (event) event.preventDefault();

                    await axios.post('/api/draft/{{ draft.hash() }}/submit', {
                        images: this.images.map(img => ({ img: img.image.data(), label: this.imageLabels[img.image.hash] }))
                    });
                },

                async deleteSet() {
                    if (!confirm("Are you sure you want to delete this set? This action cannot be undone.")) {
                        return;
                    }

                    await axios.delete('/api/draft/{{ draft.hash() }}');
                    window.location.href = '/';
                }
            }));
        });
    </script>
{% endblock %}
