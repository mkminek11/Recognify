{% extends "base.html" %}

{% block content %}
    <h1>Create a New Set</h1>
    <div x-data="formHandler">
        <dialog x-ref="inaturalistDialog">
            <button @click="$refs.inaturalistDialog.close()">Close</button>
            <h2>Import from iNaturalist</h2>
            <p>Write species names here, each on a new line.</p>
            <textarea x-ref="inaturalistTextarea"></textarea>
            <button @click="importFromInaturalist()">Import</button>
        </dialog>

        <dialog x-ref="importedImagesDialog">
            <button @click="$refs.inaturalistDialog.close()">Close</button>
            <h2>Imported Images</h2>

            <div>
                <template x-for="([species, images], spIndex) in Object.entries(importedImageLinks)" :key="spIndex">
                    <div>
                        <p x-text="species"></p>
                        <template x-for="(image, index) in images" :key="index">
                            <div>
                                <input type="checkbox" :id="`imported_${spIndex}_${image.id}`" x-model="image.selected" />
                                <label x-bind:for="`imported_${spIndex}_${image.id}`">
                                    <img :src="image.imageLink" width="100"
                                        :class="{ 'checked': image.selected }" />
                                </label>
                            </div>
                        </template>
                        <hr>
                    </div>
                </template>
            </div>

            <button :disabled="!anyImageSelected()" @click="insertImportedImages()">Insert</button>
        </dialog>

        <div>
            <label for="name">Set title:</label>
            <input type="text" id="name" x-ref="titleInput" x-model="title" x-show="titleEditMode" @blur="saveTitle();" />
            <span x-text="title" x-show="!titleEditMode" @click="titleEditMode = true; $nextTick(() => $refs.titleInput.focus())"></span>
        </div>
    
        <label for="description">Description:</label>
        <textarea id="description" x-model="setDescription" @blur="saveDescription()"></textarea>

        <button @click="deleteSet">Delete Set</button>
    
        <div>
            <p>Add images:</p>
            <label for="images" class="btn">Upload</label>
            <input type="file" id="images" class="hidden" x-ref="imageInput" multiple @change="addImages($event)" />

            <input type="url" id="img_url" x-ref="imgURL" placeholder="Image URL" />
            <button @click="addURL">Add URL</button>

            <label for="pres" class="btn">Extract from a presentation</label>
            <input type="file" id="pres" class="hidden" x-ref="presInput" @change="preparePres($event)" />

            <button @click="$refs.inaturalistDialog.showModal()">Import from iNaturalist</button>

            <div x-ref="imageList">
                <template x-for="(image, index) in images" :key="index">
                    <div>
                        <img :src="image.image.data" width="100" />
                        <input type="text" 
                               :id="`input_${index}`"
                               x-model="imageLabels[image.image.hash]" 
                               placeholder="Enter image caption" 
                               @blur="saveImageLabel(index)" 
                               @input="imageInput($event, index)" />
                        <button @click="removeImage(index)" tabindex="-1">Remove</button>
                        <label for="change_from_file" @click="changeFromFile(index)" tabindex="-1">Change from file</label>
                        <button @click="changeFromURL(index)" tabindex="-1">Change from URL</button>
                        <ul>
                            <template x-for="(label, labelIndex) in labels.filter(l => l.slide === image.slide)" :key="labelIndex">
                                <li x-text="`${labelIndex + 1}. ${label.label}`"></li>
                            </template>
                        </ul>
                    </div>
                </template>
            </div>
        </div>
    
        <button @click="submitForm">Create Set</button>
        <input type="file"
               id="change_from_file"
               class="hidden-fixed"
               x-ref="changeFromFileInput"
               @change="changeFromFileEvent($event)"
               accept="image/*" />
    </div>
{% endblock %}

{% block scripts %}
    <script type="module">
        import { CustomImage } from '/static/js/CustomImage.js';
        window.CustomImage = CustomImage;
    </script>

    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('formHandler', () => ({
                title: '{{ draft.name or "Untitled Set" }}',
                setDescription: '{{ draft.description or "" }}',
                titleEditMode: true,
                images: [], // [ { image: CustomImage, slide: string } ]
                imageLabels: {}, // { imageHash: string -> label: string }
                labels: [], // list of { label: string, slide: string }
                importedImageLinks: {}, // { species: string -> [
                                        //     { imageLink: string, label: string, id: int, selected: boolean }
                                        // ] }

                init() {
                    this.$refs.titleInput.focus();
                    this.$refs.imageInput.value = '';
                    this.$refs.presInput.value = '';
                    this.fetchGallery();
                },

                async saveTitle() {
                    this.titleEditMode = false;
                    if (!this.title.trim()) {this.title = 'Untitled Set';}

                    this.title = this.title.trim();
                    const result = await axios.post('/api/draft/{{ draft.hash() }}/rename', { title: this.title });
                },

                async saveDescription() {
                    const result = await axios.post('/api/draft/{{ draft.hash() }}/description', { description: this.setDescription });
                },

                async saveImageLabel(index) {
                    console.log("Blur");
                    const image = this.images[index].image;
                    const label = this.imageLabels[image.hash] || '';
                    await axios.post('/api/draft/{{ draft.hash() }}/image/' + image.dbid, { label });
                },

                removeImage(index) {
                    const image = this.images[index].image;
                    if (image && image.hash) {
                        delete this.imageLabels[image.hash];
                    }
                    this.images.splice(index, 1);

                    axios.delete('/api/draft/{{ draft.hash() }}/image/' + image.dbid);
                },

                async addImages(event) {
                    const fd = new FormData();
                    const files = event.target.files;
                    let added = 0;

                    for (const file of files) {
                        // if (file.size > 10 * 1024 * 1024) {continue;} // 10MB limit
                        fd.append('images', file);

                        const cimg = window.CustomImage.fromFile(file);
                        await cimg.ready;

                        if (!this.images.some(existing => existing.image.hash === cimg.hash)) {
                            this.images.push({ image: cimg, slide: "" });
                            this.imageLabels[cimg.hash] = '';
                            added++;
                        }
                    }

                    let ids = await axios.post('/api/draft/{{ draft.hash() }}/gallery', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    for (let i = 0; i < added; i++) {
                        this.images[this.images.length - added + i - 1].image.dbid = ids.data.images[i].id;
                    }
                },

                async addURL() {
                    const url = this.$refs.imgURL.value.trim();
                    if (!url) return;

                    try {
                        const cimg = await window.CustomImage.fromUrl(url);
                        await cimg.ready;

                        if (this.images.some(existing => existing.image.hash === cimg.hash)) {
                            alert("This image is already added.");
                            return;
                        }

                        const result = await axios.post('/api/draft/{{ draft.hash() }}/gallery/url', { url });
                        cimg.dbid = result.data.id;

                        this.images.push({ image: cimg, slide: "" });
                        this.imageLabels[cimg.hash] = '';

                        this.$refs.imgURL.value = '';
                    } catch (error) {
                        alert("Failed to add image from URL.");
                        console.error(error);
                    }
                },

                changeFromFile(index) {
                    this.$refs.changeFromFileInput.dataset.index = index;
                },

                async changeFromFileEvent(event) {
                    const index = this.$refs.changeFromFileInput.dataset.index;
                    const file = event.target.files[0];
                    if (!file) return;

                    const fd = new FormData();
                    fd.append('image', file);
                    fd.append('change_id', this.images[index].image.dbid);
                    const cimg = window.CustomImage.fromFile(file, this.images[index].image.dbid);
                    await cimg.ready;

                    await axios.post('/api/draft/{{ draft.hash() }}/change/image', fd, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    this.images[index].image = cimg;
                    this.$refs.changeFromFileInput.value = '';
                },

                async changeFromURL(index) {
                    url = prompt("Insert image URL:");
                    if (!url) {return;}
                    const cimg = await window.CustomImage.fromUrl(url, this.images[index].image.dbid);
                    await cimg.ready;
                    
                    const fd = new FormData();
                    fd.append('url', url);
                    fd.append('change_id', cimg.dbid);
                    await axios.post('/api/draft/{{ draft.hash() }}/change/url', fd);

                    this.images[index].image = cimg;
                },

                async preparePres(event) {
                    const file = event.target.files[0];
                    if (!file) return;
                    // if (file.size > 50 * 1024 * 1024) {return;} // 50MB limit
                    // Musel jsem to zakomentovat kvuli prezentaci na rostliny, ktera mela pres pul giga xd

                    const formData = new FormData();
                    formData.append('presentation', file);
                    formData.append('draft', '{{ draft.hash() }}');

                    const results = await axios.post('/api/draft/presentation', formData, {
                        headers: { 'Content-Type': 'multipart/form-data' }
                    });

                    const images = results.data.images || [];
                    const labels = results.data.labels || [];
                    console.log("Presentation images:", images);
                    await this.addToGallery(images, labels);
                },

                async fetchGallery() {
                    const result = await axios.get('/api/draft/{{ draft.hash() }}/gallery');
                    const images = result.data.images || [];
                    const labels = result.data.labels || [];
                    await this.addToGallery(images, labels);
                },

                async addToGallery(images, labels = []) {
                    // Process all images in parallel instead of sequentially
                    const imagePromises = images.map(async (imageData) => {
                        const cimg = await window.CustomImage.fromUrl('/api/draft/{{ draft.hash() }}/image/' + imageData.id, imageData.id);
                        await cimg.ready;
                        return { cimg, imageData };
                    });
                    
                    const imageResults = await Promise.all(imagePromises);
                    
                    for (const { cimg, imageData } of imageResults) {
                        if (!this.images.some(existing => existing.image.hash === cimg.hash)) {
                            this.images.push({ image: cimg, slide: imageData.slide });
                            this.imageLabels[cimg.hash] = imageData.label || '';
                        }
                    }

                    for (const labelData of labels) {
                        if (!this.labels.some(existing => existing.label === labelData.text && existing.slide === labelData.slide)) {
                            this.labels.push({ label: labelData.text, slide: labelData.slide });
                        }
                    }
                },

                imageInput(event, index) {
                    const image = this.images[index].image;
                    const input = event.target;
                    const value = input.value;

                    console.log("Input ", input, " changed for image", image.hash, "to", value);

                    if (!/^[1-9]$/.test(value)) {return;}

                    const nextIndex = index + 1;
                    this.$nextTick(() => {
                        const number = parseInt(value, 10);
                        const label = this.labels.filter(l => l.slide === image.slide)[number - 1].label;
                        console.log("Mapped number", number, "to label", label);

                        // Set the value and focus next input
                        this.imageLabels[image.hash] = label;
                        
                        // Focus the next input using getElementById
                        if (nextIndex >= this.images.length) {return;}
                        this.$nextTick(() => {
                            this.saveImageLabel(index);
                            
                            const nextInput = document.getElementById(`input_${nextIndex}`);
                            console.log("Next input:", nextInput, "index:", nextIndex);
                            if (nextInput) {
                                nextInput.focus();
                                nextInput.select(); // Select text for better UX
                            } else {
                                console.log("Input not found for id:", `input_${nextIndex}`);
                            }
                        });
                    });
                },

                async submitForm(event) {
                    if (event) event.preventDefault();

                    await axios.post('/api/draft/{{ draft.hash() }}/submit', {
                        images: this.images.map(img => ({ img: img.image.data(), label: this.imageLabels[img.image.hash] }))
                    });
                },

                async deleteSet() {
                    if (!confirm("Are you sure you want to delete this set? This action cannot be undone.")) {
                        return;
                    }

                    await axios.delete('/api/draft/{{ draft.hash() }}');
                    window.location.href = '/';
                },

                async importFromInaturalist() {
                    const textarea = this.$refs.inaturalistTextarea;
                    const speciesNames = textarea.value.split('\n').map(name => name.trim()).filter(name => name);
                    this.$refs.inaturalistDialog.close();

                    await axios.get('/api/inaturalist/links', {
                        params: { species: speciesNames.join(',') }
                    }).then(async (response) => {
                        const imageSets = response.data.links || {};
                        this.importedImageLinks = {};
                        this.$refs.importedImagesDialog.showModal();

                        console.log("Received image sets:", imageSets);
                        
                        for (const [species, urls] of Object.entries(imageSets)) {
                            for (let i = 0; i < urls.length; i++) {
                                const url = urls[i];
                                console.log("Processing URL:", url);
                                let id = i;
                                this.importedImageLinks[species] = this.importedImageLinks[species] || [];
                                this.importedImageLinks[species].push({ imageLink: url, label: species, id: id, selected: false });
                            }
                        }

                        console.log("Imported image links:", this.importedImageLinks);
                    });
                },
            
                async insertImportedImages() {
                    this.$refs.importedImagesDialog.close();

                    // Collect all selected images first
                    const selectedImages = [];
                    for (const species in this.importedImageLinks) {
                        for (const imageData of this.importedImageLinks[species]) {
                            if (imageData.selected) {
                                selectedImages.push(imageData);
                            }
                        }
                    }

                    // Process all selected images in parallel
                    const imagePromises = selectedImages.map(async ({ imageLink: url, label, id }) => {
                        const cimg = await window.CustomImage.fromUrl(url);
                        await cimg.ready;
                        return { cimg, label, url };
                    });
                    
                    const imageResults = await Promise.all(imagePromises);
                    
                    // Add images to gallery sequentially to maintain order
                    for (const { cimg, label, url } of imageResults) {
                        if (this.images.some(existing => existing.image.hash === cimg.hash)) {
                            alert("This image is already added.");
                            continue;
                        }

                        const result = await axios.post('/api/draft/{{ draft.hash() }}/gallery/url', { url });
                        cimg.dbid = result.data.id;

                        this.images.push({ image: cimg, slide: "" });
                        this.imageLabels[cimg.hash] = label;

                        axios.post('/api/draft/{{ draft.hash() }}/image/' + cimg.dbid, { label });
                    }
                },

                anyImageSelected() {
                    return Object.values(this.importedImageLinks).some(images => images.some(image => image.selected));
                },
            }));
        });
    </script>
{% endblock %}
